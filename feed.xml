<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title></title>
    <description>Chia sẻ, hướng dẫn lập trình Java miễn phí và chất lượng nhất.</description>
    <link>/</link>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sat, 16 Mar 2019 09:07:11 +0000</pubDate>
    <lastBuildDate>Sat, 16 Mar 2019 09:07:11 +0000</lastBuildDate>
    <generator>Jekyll v3.8.5</generator>
    
      <item>
        <title>ThanosJS - làm biến mất 1 nửa DỮ LIỆU PC với 1 dòng lệnh</title>
        <description>&lt;p&gt;Nhìn hình thì các bạn cũng biết phải làm gì rồi chứ :))) &lt;strong&gt;Bưng&lt;/strong&gt;, nửa số files trong máy bạn biến mất.&lt;/p&gt;

&lt;p&gt;Nếu chưa, thì làm như mình hướng dẫn nhé :3&lt;/p&gt;

&lt;h4 id=&quot;cài-đặt&quot;&gt;Cài đặt&lt;/h4&gt;

&lt;p&gt;Trước hết bạn cần cài Ruby Gem.&lt;/p&gt;

&lt;p&gt;Windows:&lt;/p&gt;
&lt;div class=&quot;language-css highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;https&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;://&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;rubyinstaller&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;.org&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;downloads&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Unix:&lt;/p&gt;
&lt;div class=&quot;language-css highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;sudo&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;apt-get&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;install&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;ruby-dev&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;xóa-nửa-dân-số&quot;&gt;Xóa nửa dân số&lt;/h4&gt;

&lt;p&gt;Lắp ngọc &lt;code class=&quot;highlighter-rouge&quot;&gt;Power&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;language-css highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;gem&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;install&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;power&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Lắp ngọc &lt;code class=&quot;highlighter-rouge&quot;&gt;Reality&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;language-css highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;gem&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;install&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;reality&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Lắp ngọc &lt;code class=&quot;highlighter-rouge&quot;&gt;Mind&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;language-css highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;gem&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;install&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;mind&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Lắp ngọc &lt;code class=&quot;highlighter-rouge&quot;&gt;Space&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;language-css highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;gem&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;install&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;space&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Lắp ngọc &lt;code class=&quot;highlighter-rouge&quot;&gt;Time&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;language-css highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;gem&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;install&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;time&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Lắp ngọc &lt;code class=&quot;highlighter-rouge&quot;&gt;Soul&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;language-css highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;gem&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;install&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;soul&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Búng tay&lt;/p&gt;
&lt;div class=&quot;language-css highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;thanos&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;snap-fingers&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--with-glove&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Chúc bạn khôi phục dữ liệu may mắn!&lt;/p&gt;
</description>
        <pubDate>Mon, 11 Mar 2019 00:00:00 +0000</pubDate>
        <link>/ThanosJS-lam-bien-mat-1-nua-DU-LIEU-may-ban-voi-1-dong-lenh/</link>
        <guid isPermaLink="true">/ThanosJS-lam-bien-mat-1-nua-DU-LIEU-may-ban-voi-1-dong-lenh/</guid>
        
        <category>featured</category>
        
        
        <category>ruby</category>
        
        <category>thanosjs</category>
        
      </item>
    
      <item>
        <title>Mình đã làm xe tự lái như thế nào?</title>
        <description>&lt;h2 id=&quot;đôi-nét-về-xe-tự-hành&quot;&gt;Đôi nét về Xe tự hành&lt;/h2&gt;

&lt;p&gt;Chắc hẳn những cụm từ như &lt;code class=&quot;highlighter-rouge&quot;&gt;“Xe tự hành”&lt;/code&gt; (hay &lt;code class=&quot;highlighter-rouge&quot;&gt;“Xe tự lái”&lt;/code&gt;) đã không còn xa lạ đối với những người quan tâm tới công nghệ trong suốt thời gian qua. Đã có rất nhiều tập đoàn, công ty lớn tham gia vào vào cuộc đua nghiên cứu xe tự hành này, tiêu biểu có thể kể tới như &lt;code class=&quot;highlighter-rouge&quot;&gt;Uber&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;Apple&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;Ford&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;Honda&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;BWM&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;Liên minh Renault&lt;/code&gt; – &lt;code class=&quot;highlighter-rouge&quot;&gt;Nissan&lt;/code&gt; – &lt;code class=&quot;highlighter-rouge&quot;&gt;Mitsubishi&lt;/code&gt;,.. Theo số liệu báo cáo từ KPMG thì tổng số tiền đầu tư vào lĩnh vực này trong 05 năm vừa qua đã đạt tới con số hơn 50 tỷ USD (ờ hớ ờ hớ)&lt;/p&gt;

&lt;p&gt;Cho những bạn chưa biết, thì “xe tự hành” có thể hiểu là ôtô có khả năng hoạt động mà không cần đến sự điều khiển hay can thiệp của con người.&lt;/p&gt;

&lt;p&gt;Nếu xe tự hành được nghiên cứu và áp dụng thành công thì những lợi ích mà nó đem lại sẽ có tác động rất tích cực đến chất lượng đời sống của con người như: giảm tỷ lệ tai nạn giao thông do bất cẩn của người lái, giảm thiểu chi phí sửa chữa ô tô; hỗ trợ người tàn tật, người già di chuyển dễ dàng, chủ động hơn.&lt;/p&gt;

&lt;h2 id=&quot;hành-trình-đáng-nhớ-với-cuộc-đua-số&quot;&gt;Hành trình đáng nhớ với “Cuộc đua số”&lt;/h2&gt;

&lt;p&gt;Đây là chân dung chiếc xe tự hành mini của chúng mình. Xe được xây dựng trên tỉ lệ 1:20 so với xe thật, có kích thước chiều dài khoảng 40cm và chiều cao 30cm.&lt;/p&gt;

&lt;p&gt;Em xe này có tốc độ chạy tối đa 25 km/h, có thể leo trèo bãi đất, bãi cát, leo dốc 45 độ, lội nước sâu tầm 10 cm, lội tuyết, sình lầy (cũng khá ngầu phải không :P)&lt;/p&gt;

&lt;div class=&quot;wrapper-center&quot;&gt;
    &lt;img src=&quot;/assets/images/loda1551603987/2.jpg&quot; alt=&quot;Xe tự lái&quot; /&gt;
&lt;/div&gt;

&lt;p&gt;Chi tiết hơn thì chiếc xe gồm có:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Động cơ điều khiển bánh&lt;/li&gt;
  &lt;li&gt;Vi mạch Jetson TX1&lt;/li&gt;
  &lt;li&gt;Camera&lt;/li&gt;
  &lt;li&gt;Cảm biến vật cản&lt;/li&gt;
  &lt;li&gt;Màn hình led và các phím chức năng&lt;/li&gt;
  &lt;li&gt;Dây nối tín hiệu cho mạch và dây nguồn cho động cơ/mạch&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Sau đây, mình sẽ chia sẻ qua một chút về quá trình team mình lập trình chiếc xe này và đi vào từng bài toán mà bọn mình cần giải quyết. Thật đáng tiếc là cuộc thi đã trôi qua được 1 năm, và source code mình đã gửi lại cho ban tổ chức, cũng như không còn lưu giữ gì về nó :’( mình sẽ chia sẻ hướng giải quyết vấn đề. còn source code sẽ tự bổ sung lại dần dần sau này.&lt;/p&gt;

&lt;h3 id=&quot;xác-định-2-biên-đường&quot;&gt;Xác định 2 biên đường&lt;/h3&gt;

&lt;p&gt;Để xe có thể đi đúng thì cần xác định 2 biên đường để đảm bảo xe luôn đi trong đó. Đây là một bài toán xử lý ảnh cơ bản vì 2 làn đường có màu trắng trên nền đen và bỏ qua yếu tố ngoại cảnh như nhiễu hạt hay vật cản.&lt;/p&gt;

&lt;p&gt;Ngoài ra, xe chỉ cần xác định đoạn đường trước nó không xa, nên mình cắt 1 nửa ảnh, lấy đoạn đường phía dưới để xử lý. Mình đã sử dụng lọc màu trên kênh HSV để làm nổi bật các đường màu trắng, sau đó sử dụng &lt;code class=&quot;highlighter-rouge&quot;&gt;thuật toán Canny&lt;/code&gt; để cho ra biên ảnh. Từ Canny mình có thể xác định được các đường thẳng trong ảnh =&amp;gt; chính là các làn đường trong ảnh.&lt;/p&gt;

&lt;div class=&quot;wrapper-center&quot;&gt;
    &lt;img src=&quot;/assets/images/loda1551603987/3.png&quot; alt=&quot;Xe tự lái&quot; /&gt;
&lt;/div&gt;

&lt;p&gt;Tham khảo thuật toán Canny &lt;a href=&quot;https://docs.opencv.org/3.1.0/da/d22/tutorial_py_canny.html&quot;&gt;tại đây.&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;xác-định-tâm-đường&quot;&gt;Xác định tâm đường&lt;/h3&gt;

&lt;p&gt;Khi đã xác định được 2 làn đường, việc xác định tâm đường sẽ đơn giản với đoạn đường thẳng đó là lấy trung điểm của 2 làn đường.&lt;/p&gt;

&lt;p&gt;Tại mỗi lần di chuyển, hình ảnh camera bắt được sẽ thay đổi theo thời gian nên tâm đường sẽ bị dịch chuyển, nhưng phải nằm trong giới hạn thay đổi nhất định, tâm đường mới không được quá lệch với tâm đường trước, thuật toán của bọn mình sẽ đặt ra 1 giới hạn để tránh tâm đường thay đổi đột ngột.&lt;/p&gt;

&lt;p&gt;Tuy nhiên, có trường hợp đặc biệt là đoạn đường cong. Sẽ không thể lấy trung điểm nữa mà phải sử dụng thuật toán hồi quy để suy diễn từ các tâm đường trước đó.&lt;/p&gt;

&lt;p&gt;Đây là thuật toán chính để giúp xe luôn đi trong đường quy định. Mình sẽ bổ sung thuật toán này sớm nhất khi nhớ lại source code huhu.&lt;/p&gt;

&lt;h3 id=&quot;xe-di-chuyển&quot;&gt;Xe di chuyển&lt;/h3&gt;

&lt;p&gt;Khi đã xác định được tâm đường, thì việc cho xe di chuyển chỉ là đi theo cái tâm ý, và cứ nhăm nhăm mà đi thôi. Chỉ khó ở việc cho xe rẽ ở đoạn đường cong, sẽ phải điều chỉnh độ nghiêng của bánh lớn hơn 2 lần. Tốc độ di chuyển giảm xuống khoảng 0.65&lt;/p&gt;

&lt;h3 id=&quot;xác-định-vật-cản&quot;&gt;Xác định vật cản&lt;/h3&gt;

&lt;p&gt;Trên đường đi, vật cản được quy định là &lt;code class=&quot;highlighter-rouge&quot;&gt;khối hộp màu xanh&lt;/code&gt; và &lt;code class=&quot;highlighter-rouge&quot;&gt;đỏ&lt;/code&gt; điều này khá dễ dàng để có thể nhận biết, chỉ 1 vài phép biến đổi ảnh đơn giản như Color Filter, &lt;a href=&quot;https://docs.opencv.org/3.1.0/dd/d49/tutorial_py_contour_features.html&quot;&gt;Convex Hull&lt;/a&gt; là sẽ ra. Thuật toán bạn tham khảo tại đây &lt;a href=&quot;https://docs.opencv.org/3.1.0/dd/d49/tutorial_py_contour_features.html&quot;&gt;tại đây&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;youtube-container&quot;&gt;
    &lt;iframe src=&quot;https://www.youtube.com/embed/BaAmaIyCp2Y&quot; frameborder=&quot;0&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;h3 id=&quot;xác-định-biển-báo-rẽ-đường&quot;&gt;Xác định biển báo rẽ đường&lt;/h3&gt;

&lt;p&gt;Trong phần xác định biển báo rẽ trái hoặc rẽ phải. Mình sẽ dụng màu xanh nước biển là bộ lọc, sau đó xác định Contour và bao viền biển báo. Cái này cần ốp machine learning mạnh mẽ vào :v&lt;/p&gt;

&lt;p&gt;Khi đã biết được biển báo ở đâu, mình sẽ sử dụng thuật toán trích đặc trưng của biển báo là HOG và đưa vào một bộ nhận dạng đã được huấn luyện từ trước là SVM để xác định xem biển báo là gì =&amp;gt; Lúc này sẽ biết được biển báo đó là rẽ trái hay rẽ phải và điều khiển xe theo hướng đó&lt;/p&gt;

&lt;div class=&quot;wrapper-center&quot;&gt;
    &lt;img src=&quot;/assets/images/loda1551603987/4.jpg&quot; alt=&quot;Xe tự lái&quot; /&gt;
&lt;/div&gt;

&lt;p&gt;Trên đây là toàn bộ những chia sẻ của mình về việc mình đã được tham gia lập trình một chiếc Xe tự hành ở level “đơn giản” như thế nào. Hy vọng là trong tương lai sẽ không còn là dạng “mô hình” hay “level đơn giản” nữa :D&lt;/p&gt;

&lt;p&gt;Một lần nữa xin lỗi bạn đọc vì không có source code ở đây, nhưng mình sẽ bổ sung trong thời gian sớm nhất có thể. ít ra trong bài viết có những keywords khá quan trọng nếu bạn muốn tìm hiểu :D&lt;/p&gt;
</description>
        <pubDate>Sun, 10 Mar 2019 00:00:00 +0000</pubDate>
        <link>/Minh-da-lam-xe-tu-lai-nhu-the-nao/</link>
        <guid isPermaLink="true">/Minh-da-lam-xe-tu-lai-nhu-the-nao/</guid>
        
        <category>featured</category>
        
        
        <category>Image Processing</category>
        
        <category>Machine Learning</category>
        
        <category>AI</category>
        
      </item>
    
      <item>
        <title>Hướng dẫn chi tiết tự xây dựng một mạng neural với Python</title>
        <description>&lt;p&gt;Google đã xây dựng tensorflow như một công cụ để xây dựng các mô hình deep learning một các đơn giản và tối ưu chỉ với vài dòng code. Tuy nhiên, nếu chỉ sử dụng các API này thì thật khó để biết được các cách thức hoạt động đằng sau của từng thành phần trong mô hình. Bài viết này sẽ hướng dẫn các bạn cách xây dựng mạng neural một cách chi tiết qua từng dòng lệnh, từ đó có một cái nhìn rõ ràng hơn về cách hoạt động của chúng.&lt;/p&gt;

&lt;p&gt;Đây là bài viết nói về cả quá trình và các bước thực hiện trong 1 mạng neural, nên sẽ không đi sau chi tiết từng phần nhưng vẫn cung cấp cho bạn kiến thức để hiểu được vai trò của nó trong cả kiến trúc.&lt;/p&gt;
&lt;h4 id=&quot;mạng-neural-là-gì&quot;&gt;Mạng neural là gì?&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Mạng neural&lt;/code&gt; có thể coi là một phương thức để miêu tả cách hoạt động trong bộ não của con người. Nói một cách đơn giản hơn, mạng neural là một hàm nhận một đầu vào &lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt;, xử lý nó và đưa ra một đầu ra &lt;code class=&quot;highlighter-rouge&quot;&gt;y&lt;/code&gt; tương ứng. Mạng neural gồm những thành phần sau:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Một lớp biểu diễn đầu vào &lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Một số lượng các lớp ẩn - &lt;code class=&quot;highlighter-rouge&quot;&gt;hidden layers&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Một lớp biểu diễn đầu ra &lt;code class=&quot;highlighter-rouge&quot;&gt;y&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Một bộ các chỉ số &lt;code class=&quot;highlighter-rouge&quot;&gt;weights(W)&lt;/code&gt; và &lt;code class=&quot;highlighter-rouge&quot;&gt;bias(b)&lt;/code&gt; giữa các lớp&lt;/li&gt;
  &lt;li&gt;Một hàm kích hoạt - &lt;code class=&quot;highlighter-rouge&quot;&gt;activation function&lt;/code&gt; giữa các lớp&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Hình dưới đây miêu tả một kiến trúc mạng neural gồm 2 lớp (lớp đầu vào &lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt; thường không được tính vào số lượng lớp của mạng)&lt;/p&gt;

&lt;div class=&quot;wrapper-center&quot;&gt;
    &lt;img src=&quot;https://cdn.ereka.vn/2018/06/24/c41f7da2e8698e1a8616572f668b3a5d.jpg&quot; alt=&quot;Neural network, mạng nơ ron, neurol&quot; /&gt;
&lt;/div&gt;

&lt;p&gt;Giờ thì chúng ta sẽ bắt đầu xây dựng kiến trúc trên với Python. Đầu tiên là khởi tạo class &lt;code class=&quot;highlighter-rouge&quot;&gt;NeuralNetwork&lt;/code&gt;. Để đơn giản hóa mô hình, ta sẽ mặc định là các biến &lt;code class=&quot;highlighter-rouge&quot;&gt;bias&lt;/code&gt; bằng 0.&lt;/p&gt;

&lt;div class=&quot;wrapper-center&quot;&gt;
    &lt;img src=&quot;https://cdn.ereka.vn/2018/06/24/e5ea3a08be22cc40f7d3ebc7b1536ec9.jpg&quot; alt=&quot;Neurol network, mạng nơ ron&quot; /&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;huấn-luyện-mạng-neural&quot;&gt;Huấn luyện mạng neural&lt;/h4&gt;

&lt;p&gt;Với kiến trúc trên, biến &lt;code class=&quot;highlighter-rouge&quot;&gt;ŷ&lt;/code&gt; thể hiển đầu ra của mạng sẽ được tính theo công thức:&lt;/p&gt;

&lt;div class=&quot;wrapper-center&quot;&gt;
    &lt;img src=&quot;https://cdn.ereka.vn/2018/06/24/0ae2983de3bf3868aaf3b2a8a03cbe50.jpg&quot; alt=&quot;Neurol network, mạng nơ ron&quot; /&gt;
&lt;/div&gt;

&lt;p&gt;Theo công thức trên, có thể thấy được rằng các biến weights &lt;code class=&quot;highlighter-rouge&quot;&gt;W&lt;/code&gt; và bias &lt;code class=&quot;highlighter-rouge&quot;&gt;b&lt;/code&gt; đóng vai trò quyết định đầu ra &lt;code class=&quot;highlighter-rouge&quot;&gt;ŷ&lt;/code&gt;. Giá trị của các biến này cần được tinh chỉnh để tăng độ chính xác trong những dự đoán của mạng neural. Quá trình tinh chỉnh các biến này được gọi là quá trình huấn luyện mạng. Quá trình này là một vòng lặp gồm các bước:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Feedforward: Tính toán đầu ra ŷ&lt;/li&gt;
  &lt;li&gt;Backpropagation: Cập nhật các giá trị W và b&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Mỗi vòng lặp trong quá trình huấn luyện diễn ra như sau:&lt;/p&gt;

&lt;div class=&quot;wrapper-center&quot;&gt;
    &lt;img src=&quot;https://cdn.ereka.vn/2018/06/24/0826eda2cb11e6b19dfbcd642eea15d9.jpg&quot; alt=&quot;Neurol network, mạng nơ ron&quot; /&gt;
&lt;/div&gt;

&lt;p&gt;Chúng  ta sẽ đi vào chi tiết từng phần&lt;/p&gt;

&lt;h4 id=&quot;feedforward&quot;&gt;Feedforward&lt;/h4&gt;

&lt;div class=&quot;wrapper-center&quot;&gt;
    &lt;img src=&quot;https://cdn.ereka.vn/2018/06/24/b78d20ec7ad65706669e51ccb33001f7.jpg&quot; alt=&quot;Neurol network, mạng nơ ron&quot; /&gt;
&lt;/div&gt;

&lt;p&gt;Code hàm feedforward:&lt;/p&gt;

&lt;div class=&quot;wrapper-center&quot;&gt;
    &lt;img src=&quot;https://cdn.ereka.vn/2018/06/24/140c1d14416323166b5d48b1bebede80.jpg&quot; alt=&quot;Neurol network, mạng nơ ron&quot; /&gt;
&lt;/div&gt;

&lt;p&gt;Sau bước feedforward, ta đã tính được đầu ra &lt;code class=&quot;highlighter-rouge&quot;&gt;ŷ&lt;/code&gt; của mạng neural. Tuy nhiên ta vẫn chưa xây dựng một cách thức để đánh giá mức độ đúng đắn của dự đoán này. Phương thức phổ biến nhất dùng để đánh giá mức độ chênh lệch giữa dự đoán &lt;code class=&quot;highlighter-rouge&quot;&gt;ŷ&lt;/code&gt; (Giá trị output của mạng) với kết quả mong muốn &lt;code class=&quot;highlighter-rouge&quot;&gt;y&lt;/code&gt; (Giá trị output thực sự mà ta muốn) là sử dụng &lt;code class=&quot;highlighter-rouge&quot;&gt;hàm mất mát&lt;/code&gt; - &lt;code class=&quot;highlighter-rouge&quot;&gt;Loss function&lt;/code&gt;.&lt;/p&gt;

&lt;h4 id=&quot;hàm-mất-mát---loss-function&quot;&gt;hàm mất mát - Loss function&lt;/h4&gt;

&lt;p&gt;Là một hàm để tính toán mức độ chênh lệch giữa &lt;code class=&quot;highlighter-rouge&quot;&gt;ŷ&lt;/code&gt; và &lt;code class=&quot;highlighter-rouge&quot;&gt;y&lt;/code&gt;. Vì giá trị độ chênh lệch này biểu diễn sự sai sót trong quá trình dự đoán của mạng nên giá trị này còn được gọi là giá trị lỗi. Giá trị lỗi càng nhỏ thì dự đoán của mạng neural càng chính xác. Có rất nhiều biến thể của hàm mất mát phù hợp cho từng bài toán khác nhau, trong bài viết này ta sẽ sử dụng &lt;code class=&quot;highlighter-rouge&quot;&gt;hàm tổng bình phương lỗi (Sum of square error)&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;wrapper-center&quot;&gt;
    &lt;img src=&quot;https://cdn.ereka.vn/2018/06/24/e1598a29bf04dca6891f788c9f4231bc.jpg&quot; alt=&quot;Neurol network, mạng nơ ron&quot; /&gt;
&lt;/div&gt;

&lt;p&gt;Giống như cái tên hàm tổng bình phương lỗi, giá trị lỗi được tính theo tổng bình phương của độ chệnh lệch của từng dự đoán &lt;code class=&quot;highlighter-rouge&quot;&gt;ŷ&lt;/code&gt; với mong muốn &lt;code class=&quot;highlighter-rouge&quot;&gt;y&lt;/code&gt; tương ứng. Mục tiêu của việc huấn luyện mạng là giảm giá trị lỗi này đến mức tối thiểu và quá trình &lt;code class=&quot;highlighter-rouge&quot;&gt;backpropagation&lt;/code&gt; sẽ thực hiện điều đó.&lt;/p&gt;

&lt;h4 id=&quot;backpropagation&quot;&gt;Backpropagation&lt;/h4&gt;

&lt;p&gt;Sau khi đã tính được giá trị lỗi, ta cần phải cập nhật các biến &lt;code class=&quot;highlighter-rouge&quot;&gt;W&lt;/code&gt; và &lt;code class=&quot;highlighter-rouge&quot;&gt;b&lt;/code&gt; sao cho các dự đoán &lt;code class=&quot;highlighter-rouge&quot;&gt;ŷ&lt;/code&gt; về sau có giá trị lỗi nhỏ nhất có thể. Nhắc lại kiến thức về giải tích, để tìm cực tiểu của một hàm số ta phải tính đạo hàm của hàm số đó theo từng biến. Các giá trị đạo hàm nói cho ta biết về các “hướng” cần di chuyển các biến để hàm số đi về cực tiểu. Vì vậy, một khi ta đã có đạo hàm của hàm mất mát theo từng biến &lt;code class=&quot;highlighter-rouge&quot;&gt;W&lt;/code&gt; và &lt;code class=&quot;highlighter-rouge&quot;&gt;b&lt;/code&gt;, ta sẽ cập nhật các giá trị của chúng theo giá trị các đạo hàm tương ứng. Phương pháp này được gọi là &lt;code class=&quot;highlighter-rouge&quot;&gt;gradient descent&lt;/code&gt;.&lt;/p&gt;

&lt;div class=&quot;wrapper-center&quot;&gt;
    &lt;img src=&quot;https://cdn.ereka.vn/2018/06/24/197db08dfd1c6c9468107d4c24a35234.jpg&quot; alt=&quot;Neurol network, mạng nơ ron&quot; /&gt;
&lt;/div&gt;

&lt;p&gt;Để tính toán các đạo hàm của hàm mất mát theo từng biến &lt;code class=&quot;highlighter-rouge&quot;&gt;W&lt;/code&gt; và &lt;code class=&quot;highlighter-rouge&quot;&gt;b&lt;/code&gt;, ta sử dụng quy tắc tính đạo hàm của hàm số hợp như sau:&lt;/p&gt;

&lt;div class=&quot;wrapper-center&quot;&gt;
    &lt;img src=&quot;https://cdn.ereka.vn/2018/06/24/30a1b23a77916951aaf216e53ceb1542.jpg&quot; alt=&quot;Neurol network, mạng nơ ron&quot; /&gt;
&lt;/div&gt;

&lt;p&gt;Code hàm Backpropagate:&lt;/p&gt;

&lt;div class=&quot;wrapper-center&quot;&gt;
    &lt;img src=&quot;https://cdn.ereka.vn/2018/06/24/e3ad28c8cf81dd1c0dbaeb16e1f77072.jpg&quot; alt=&quot;Neurol network, mạng nơ ron&quot; /&gt;
&lt;/div&gt;

&lt;p&gt;Để có thể hiểu rõ hơn nữa về quá trình backpropagate và các tính toán đằng sau nó, các bạn nên xem video này:&lt;/p&gt;

&lt;div class=&quot;youtube-container&quot;&gt;
    &lt;iframe src=&quot;https://www.youtube.com/embed/tIeHLnjs5U8&quot; frameborder=&quot;0&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;tổng-hợp-lại&quot;&gt;Tổng hợp lại&lt;/h4&gt;

&lt;p&gt;Vậy là mạng neural 2 lớp đã được xây dựng xong, cũng không quá phức tạp phải không. Giờ ta sẽ chạy thử nó với một ví dụ đơn giản:&lt;/p&gt;

&lt;div class=&quot;wrapper-center&quot;&gt;
    &lt;img src=&quot;https://cdn.ereka.vn/2018/06/24/95e45a0bf6717825a6770b56bee22a19.jpg&quot; alt=&quot;Neurol network, mạng nơ ron&quot; /&gt;
&lt;/div&gt;

&lt;p&gt;Ta có một tập hợp đầu vào &lt;code class=&quot;highlighter-rouge&quot;&gt;X&lt;/code&gt; và đầu ra &lt;code class=&quot;highlighter-rouge&quot;&gt;Y&lt;/code&gt; như trên. Ta sẽ bắt đầu quá trình huấn luyện với 1500 vòng lặp của các bước &lt;code class=&quot;highlighter-rouge&quot;&gt;feedforward - backpropagate&lt;/code&gt; và xem biểu đồ biến thiên của hàm mất mát:&lt;/p&gt;

&lt;div class=&quot;wrapper-center&quot;&gt;
    &lt;img src=&quot;https://cdn.ereka.vn/2018/06/24/7cf9e5d1155085493585753787dfcec6.jpg&quot; alt=&quot;Neurol network, mạng nơ ron&quot; /&gt;
&lt;/div&gt;

&lt;p&gt;Sau khi đã học xong, với mỗi đầu vào theo thứ tự trên ta có đầu ra ŷ như sau:&lt;/p&gt;

&lt;div class=&quot;wrapper-center&quot;&gt;
    &lt;img src=&quot;https://cdn.ereka.vn/2018/06/24/5ec4357674b15aa963d88439f47a3ec8.jpg&quot; alt=&quot;Neurol network, mạng nơ ron&quot; /&gt;
&lt;/div&gt;

&lt;p&gt;Khá tốt phải không. Mỗi dự đoán &lt;code class=&quot;highlighter-rouge&quot;&gt;ŷ&lt;/code&gt; đã ở rất gần so với mong muốn &lt;code class=&quot;highlighter-rouge&quot;&gt;y&lt;/code&gt; rồi. Vậy là mạng neural đã được huấn luyện thành công. Hy vọng các bạn học được nhiều điều mới qua bài viết này :D.&lt;/p&gt;
</description>
        <pubDate>Thu, 07 Mar 2019 00:00:00 +0000</pubDate>
        <link>/huong-dan-chi-tiet-tu-xay-dung-mot-mang-neural-(no-ron)-voi-python/</link>
        <guid isPermaLink="true">/huong-dan-chi-tiet-tu-xay-dung-mot-mang-neural-(no-ron)-voi-python/</guid>
        
        
        <category>Machine Learning</category>
        
        <category>deep learning</category>
        
        <category>neural network</category>
        
        <category>Python</category>
        
      </item>
    
      <item>
        <title>Các Open Source AI và Deep Learning ấn tượng nhất năm 2018 (Phần 2)</title>
        <description>&lt;p&gt;Chúng ta tiếp tục đi tìm hiểu xem, ở ngoài kia, trên thế giới, họ đang sử dụng &lt;code class=&quot;highlighter-rouge&quot;&gt;Machine learning&lt;/code&gt; vào những sản phẩm tuyệt vời gì nhé. Nếu ai chưa xem phần 1 có thể xem tại:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://loda.me/cac-open-source-ai-va-deep-learning-an-tuong-nhat-nam-2018-phan-1/&quot;&gt;Các Open Source AI và Deep Learning ấn tượng nhất năm 2018 (Phần 1)&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;11-style2paints&quot;&gt;#11 Style2Paints&lt;/h4&gt;

&lt;p&gt;Trí tuệ nhân tạo có khả năng nhìn ảnh vẽ và tô màu cho nó [3310 stars on Github].&lt;/p&gt;

&lt;div class=&quot;wrapper-center&quot;&gt;
    &lt;img src=&quot;https://cdn.ereka.vn/2018/06/14/0e1b0b8d5dbf9b6f5b8792e435ba308a.png&quot; alt=&quot;machine learning, deep learning, neurol network, dữ liệu học máy, deep learning&quot; /&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;12-tensor2tensor&quot;&gt;#12 Tensor2Tensor&lt;/h4&gt;

&lt;p&gt;Thư viện sinh mô hình sequence to sequence trên tensorflow - Google Research [3087 stars on Github]. Bởi Ryan Sepassi tại Google Brain&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.ereka.vn/2018/06/14/896f58eb0878039f84e627889dca685b.jpg?w=600&quot; alt=&quot;image-title-here&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Paper này ra đời đã tạo một làn sóng trong giới khoa học, khi cho phép biến 1 bức ảnh bình thường trở thành tuyệt đẹp nhờ copy style của 1 bức ảnh khác.&lt;/p&gt;

&lt;h4 id=&quot;13-image-to-image&quot;&gt;#13 Image-to-image&lt;/h4&gt;

&lt;p&gt;Mô hình chuyển đổi xuôi và ngược từ ảnh thật sang ảnh vẽ, thay đổi object trong bức ảnh, mô hình, cực kì hay.&lt;/p&gt;

&lt;div class=&quot;wrapper-center&quot;&gt;
    &lt;img src=&quot;https://cdn.ereka.vn/2018/06/14/e2bb0d057aa8a0e1cf26cc90625d3c1d.jpg&quot; alt=&quot;machine learning, deep learning, neurol network, dữ liệu học máy, deep learning&quot; /&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;14-faiss&quot;&gt;#14 Faiss&lt;/h4&gt;

&lt;p&gt;Một thư viện mạnh mẽ cho việc tìm kiếm dữ liệu liên quan và phân nhóm vectors. [2629 stars on Github]. Thuộc Facebook Research&lt;/p&gt;

&lt;div class=&quot;wrapper-center&quot;&gt;
    &lt;img src=&quot;https://cdn.ereka.vn/2018/06/14/d53fdeef9d869591974653ea6e6df19e.png?w=600&quot; alt=&quot;machine learning, deep learning, neurol network, dữ liệu học máy, deep learning&quot; /&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;15-fashion-mnist&quot;&gt;#15 Fashion-mnist&lt;/h4&gt;

&lt;p&gt;Một bộ dữ liệu giống MNIST nhưng nó bao gồm các sản phẩm thời trang như quần áo. [2780 stars on Github]. Bởi Han Xiao thuộc Research Scientist Zalando Tech&lt;/p&gt;

&lt;div class=&quot;wrapper-center&quot;&gt;
    &lt;img src=&quot;https://cdn.ereka.vn/2018/06/14/b876dffb39c93293baa2fea76f9699d9.jpg?w=600&quot; alt=&quot;machine learning, deep learning, neurol network, dữ liệu học máy, deep learning&quot; /&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;16-parl&quot;&gt;#16 Parl&lt;/h4&gt;

&lt;p&gt;Một framework cho việc training và evaluating AI model trên một tổ hợp rộng lớn dữ liệu về hội thoại [2578 stars - Github]. Bởi Alexander Miller thuộc Facebook Research&lt;/p&gt;

&lt;div class=&quot;wrapper-center&quot;&gt;
    &lt;img src=&quot;https://cdn.ereka.vn/2018/06/14/be1c1be6fd735f2fc4c32c10ab993710.png&quot; alt=&quot;machine learning, deep learning, neurol network, dữ liệu học máy, deep learning&quot; /&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;17-igan&quot;&gt;#17 iGAN&lt;/h4&gt;

&lt;p&gt;Model có khả năng sinh ra ảnh vẽ chỉ từ vài mô tả của người dùng. [2369 stars - Github].&lt;/p&gt;

&lt;div class=&quot;wrapper-center&quot;&gt;
    &lt;img src=&quot;https://cdn.ereka.vn/2018/06/14/be0b0cfcddbc66ec94f03641a2069555.png&quot; alt=&quot;machine learning, deep learning, neurol network, dữ liệu học máy, deep learning&quot; /&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;18-deep-image-prior&quot;&gt;#18 Deep-image-prior&lt;/h4&gt;

&lt;p&gt;Sản phẩm này cũng ấn tượng không kém, khi model có khả năng phục hồi ảnh bị xóa 1 vùng, bị nhòe trở về ảnh gốc đẹp đẽ. [2188 stars - Github]&lt;/p&gt;

&lt;div class=&quot;wrapper-center&quot;&gt;
    &lt;img src=&quot;https://cdn.ereka.vn/2018/06/14/249b704475def9b9dcf03dfbb3fa9f01.png&quot; alt=&quot;machine learning, deep learning, neurol network, dữ liệu học máy, deep learning&quot; /&gt;
&lt;/div&gt;

&lt;p&gt;Các mạng học sâu đang ngày càng thể hiện sức mạnh của mình trong rất nhiều lĩnh vực mà cách đây nhiều năm chưa ai nghĩ một chiếc máy tính có khả năng tư duy được như thế.&lt;/p&gt;

&lt;p&gt;Đặc biệt, qua các project mình đã giới thiệu, có thể thấy đa phần các công nghệ mới này 3/4 là đến từ các ông lớn công nghệ như &lt;code class=&quot;highlighter-rouge&quot;&gt;Google&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;Facebook&lt;/code&gt;, v.v.. =&amp;gt; Cho thấy học máy đang là một lĩnh vực lớn được chú trọng quan tâm nhất thời điểm hiện tại.&lt;/p&gt;
</description>
        <pubDate>Thu, 07 Mar 2019 00:00:00 +0000</pubDate>
        <link>/cac-open-source-ai-va-deep-learning-an-tuong-nhat-nam-2018-phan-2/</link>
        <guid isPermaLink="true">/cac-open-source-ai-va-deep-learning-an-tuong-nhat-nam-2018-phan-2/</guid>
        
        <category>featured</category>
        
        
        <category>Machine Learning</category>
        
        <category>deep learning</category>
        
        <category>neural network</category>
        
      </item>
    
      <item>
        <title>Các Open Source AI và Deep Learning ấn tượng nhất năm 2018 (Phần 1)</title>
        <description>&lt;p&gt;Trong năm vừa qua, &lt;code class=&quot;highlighter-rouge&quot;&gt;Mybridge AI&lt;/code&gt; đã thống kê và so sánh trên 8,800 open source về Machine Learning để chọn ra các projects xuất sắc nhất (0.3%)&lt;/p&gt;

&lt;p&gt;Đây là một danh sách phải đánh giá là có tính cạnh tranh cực cao, và được cân nhắc kỹ lưỡng bởi các chuyên gia. Nó bao gồm các thư viện, datasets và apps được ra mắt trong năm vừa qua.&lt;/p&gt;

&lt;p&gt;Thước đo của các project được đánh giá qua chỉ số phổ biến trong cộng đồng, mức độ tương tác, lần truy cập gần đây và ý tưởng chất, &lt;strong&gt;mức Star trung bình của các project trên Github là 3,558.&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;những-con-số-ấn-tượng&quot;&gt;NHỮNG CON SỐ ẤN TƯỢNG&lt;/h4&gt;

&lt;p&gt;Open source là một nguồn kiến thức dồi dào cho các kĩ sư. Bạn có thể học cách code và build những sản phẩm tuyệt vời trên nền tảng của nó. Hãy dành thời gian xem qua và chơi với các dự án Machine learning tuyệt vời này nhé.&lt;/p&gt;

&lt;p&gt;Hãy xem 1 năm qua chúng ta bỏ lỡ những gì nào!&lt;/p&gt;

&lt;h4 id=&quot;1-fast-text&quot;&gt;#1 Fast text&lt;/h4&gt;

&lt;p&gt;Thư viện cho text representation và classification. [11786 stars - Github] bởi Facebook Research&lt;/p&gt;

&lt;div class=&quot;wrapper-center&quot;&gt;
    &lt;img src=&quot;https://cdn.ereka.vn/2018/06/13/ab6d0856fcc80dda7a2a8e13f9b96191.png?w=600&quot; alt=&quot;machine learning, deep learning, neurol network, dữ liệu học máy, deep learning&quot; /&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;2-deep-photo-styletransfer&quot;&gt;#2 Deep-photo-styletransfer&lt;/h4&gt;

&lt;p&gt;Code và data của paper “Deep Photo Style Transfer” [9747 stars - Github]. Bởi Fujun Luan, Ph.D. thuộc Cornell University&lt;/p&gt;

&lt;div class=&quot;wrapper-center&quot;&gt;
    &lt;img src=&quot;https://cdn.ereka.vn/2018/06/13/0ff471f814a9ccd608d1f86b6754711b.png?w=600&quot; alt=&quot;machine learning, deep learning, neurol network, dữ liệu học máy, deep learning&quot; /&gt;
&lt;/div&gt;

&lt;p&gt;Paper này ra đời đã tạo một làn sóng trong giới khoa học, khi cho phép biến 1 bức ảnh bình thường trở thành tuyệt đẹp nhờ copy style của 1 bức ảnh khác.&lt;/p&gt;

&lt;h4 id=&quot;3&quot;&gt;#3&lt;/h4&gt;

&lt;p&gt;API nhận diện khuôn mặt đơn giản nhất thế giới, chạy bởi Python hoặc trực tiếp trên command line. [8672 stars - Github]. Bởi Adam Geitgey&lt;/p&gt;

&lt;div class=&quot;wrapper-center&quot;&gt;
    &lt;img src=&quot;https://cdn.ereka.vn/2018/06/13/ca25e1904ae86861b709c7ffdb220d1c.png?w=600&quot; alt=&quot;machine learning, deep learning, neurol network, dữ liệu học máy, deep learning&quot; /&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;4-magenta&quot;&gt;#4 Magenta&lt;/h4&gt;

&lt;p&gt;Sáng tác nhạc và ảnh nghệ thuật tự động dựa trên Trí thông minh nhân tạo. [8113 stars - Github].&lt;/p&gt;

&lt;div class=&quot;wrapper-center&quot;&gt;
    &lt;img src=&quot;https://cdn.ereka.vn/2018/06/13/d9f41f72607f1b910c21fb147d1174a8.png?w=600&quot; alt=&quot;machine learning, deep learning, neurol network, dữ liệu học máy, deep learning&quot; /&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;5-sonnet&quot;&gt;#5 Sonnet&lt;/h4&gt;

&lt;p&gt;Thư viện mã nguồn mở xây dựng trên nền tensorflow, phục vụ xây dựng các mạng nơ-ron network một cách đơn giản hơn. [5731 stars - Github]. Bởi Malcolm Reynolds thuộc Deepmind (Google)&lt;/p&gt;

&lt;div class=&quot;wrapper-center&quot;&gt;
    &lt;img src=&quot;https://cdn.ereka.vn/2018/06/13/c4e023e3fb689ecb73f530b3bc754779.png?w=600&quot; alt=&quot;machine learning, deep learning, neurol network, dữ liệu học máy, deep learning&quot; /&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;6-deeplearnjs&quot;&gt;#6 deeplearn.js&lt;/h4&gt;

&lt;p&gt;Thư viện machine learning và deep learning trên nền tảng web. [5462 stars - Github]. Bởi Nikhil Thorat thuộc Google Brain&lt;/p&gt;

&lt;div class=&quot;wrapper-center&quot;&gt;
    &lt;img src=&quot;https://cdn.ereka.vn/2018/06/13/8f506087e98f4cfd444f0b06772cd450.png?w=600&quot; alt=&quot;machine learning, deep learning, neurol network, dữ liệu học máy, deep learning&quot; /&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;7-fast-style-transfer&quot;&gt;#7 Fast Style Transfer&lt;/h4&gt;

&lt;p&gt;Xây đựng trên nền tảng tensorflow [4843 stars - Github]. Bởi Logan Engstrom tại MIT.&lt;/p&gt;

&lt;p&gt;Cho phéo sinh ra một bức ảnh là kết hợp style từ 2 bức ảnh đầu vào.&lt;/p&gt;

&lt;div class=&quot;wrapper-center&quot;&gt;
    &lt;img src=&quot;https://cdn.ereka.vn/2018/06/13/ea60d54ef571f02404a55b05c8b4ecfb.png?w=600&quot; alt=&quot;machine learning, deep learning, neurol network, dữ liệu học máy, deep learning&quot; /&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;8-pysc2&quot;&gt;#8 Pysc2&lt;/h4&gt;

&lt;p&gt;Pysc2: StarCraft II Learning Enviroment [3683 stars - Github]. Bởi Timo Ewalds thuộc DeepMind&lt;/p&gt;

&lt;p&gt;Một thư viện môi trường để ở đó trí tuệ nhân tạo chơi game StarCraft II. Và mục tiêu thắng con người.&lt;/p&gt;

&lt;div class=&quot;wrapper-center&quot;&gt;
    &lt;img src=&quot;https://cdn.ereka.vn/2018/06/13/27f5b5b2441f37f81b2df3c8394cfd0f.png?w=600&quot; alt=&quot;machine learning, deep learning, neurol network, dữ liệu học máy, deep learning&quot; /&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;9-airsim&quot;&gt;#9 AirSim&lt;/h4&gt;

&lt;p&gt;Open source mô phỏng thế giới thực dựa trên Unreal Engine dành cho xe tự lái của Microsoft AI &amp;amp; Research [3861 stars - Github]. Bởi Shital Shah&lt;/p&gt;

&lt;div class=&quot;wrapper-center&quot;&gt;
    &lt;img src=&quot;https://cdn.ereka.vn/2018/06/13/cce68e8e75178d828a2e0ce5bd45617c.png?w=600&quot; alt=&quot;machine learning, deep learning, neurol network, dữ liệu học máy, deep learning&quot; /&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;10-facets&quot;&gt;#10 Facets&lt;/h4&gt;

&lt;p&gt;Công cụ Visualizations dành cho dữ liệu học máy [3371 stars - Github] thuộc Google Brain&lt;/p&gt;

&lt;div class=&quot;wrapper-center&quot;&gt;
    &lt;img src=&quot;https://cdn.ereka.vn/2018/06/13/e910773ed6e96a5422f3be159213fdd9.jpg?w=600&quot; alt=&quot;machine learning, deep learning, neurol network, dữ liệu học máy, deep learning&quot; /&gt;
&lt;/div&gt;

&lt;p&gt;Phần 2:
&lt;a href=&quot;https://loda.me/cac-open-source-ai-va-deep-learning-an-tuong-nhat-nam-2018-phan-2/&quot;&gt;Các Open Source AI và Deep Learning ấn tượng nhất năm 2018 (Phần 2)&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Thu, 07 Mar 2019 00:00:00 +0000</pubDate>
        <link>/cac-open-source-ai-va-deep-learning-an-tuong-nhat-nam-2018-phan-1/</link>
        <guid isPermaLink="true">/cac-open-source-ai-va-deep-learning-an-tuong-nhat-nam-2018-phan-1/</guid>
        
        
        <category>Machine Learning</category>
        
        <category>deep learning</category>
        
        <category>neural network</category>
        
      </item>
    
      <item>
        <title>Top những ứng dụng trí tuệ nhân tạo sẽ thống trị thế giới</title>
        <description>&lt;p&gt;Trong những năm vừa qua, sự xuất hiện của Deep Learning đã giống như một bàn đạp giúp cho ngành công nghệ &lt;code class=&quot;highlighter-rouge&quot;&gt;Trí tuệ nhân tạo (AI)&lt;/code&gt; đạt được rất nhiều thành tựu nổi bật.&lt;/p&gt;

&lt;p&gt;Nổi lên như một bằng chứng của Cuộc cách mạng Công nghiệp 4.0, AI nói chung và Deep Learning nói riêng đã được ứng dụng thành công trong thực tiễn, mang lại hiệu quả vượt trội so với các phương pháp học máy truyền thống. Có thể khẳng định, Deep Learning chính là một công cụ tuyệt vời trong việc tạo ra các ứng dụng AI.&lt;/p&gt;

&lt;p&gt;Dưới đây là danh sách Top các ứng dụng Deep Learning/AI được dự đoán sẽ góp phần thay đổi thế giới trong tương lai gần:&lt;/p&gt;

&lt;div class=&quot;wrapper-center&quot;&gt;
    &lt;img src=&quot;https://cdn.ereka.vn/2018/05/05/600eec890d081916dbd0bb73a285a215.jpg&quot; alt=&quot;Machine learning, learning to learn, transfer learning&quot; /&gt;
&lt;/div&gt;
</description>
        <pubDate>Thu, 07 Mar 2019 00:00:00 +0000</pubDate>
        <link>/Nhung-ung-dung-tri-tue-nhan-tao-ai-se-thong-tri-the-gioi/</link>
        <guid isPermaLink="true">/Nhung-ung-dung-tri-tue-nhan-tao-ai-se-thong-tri-the-gioi/</guid>
        
        
        <category>Machine Learning</category>
        
        <category>deep learning</category>
        
        <category>neural network</category>
        
      </item>
    
      <item>
        <title>Bạn đã biết về 'Learning to Learn' - Lĩnh vực rất mới của Trí tuệ nhân tạo?</title>
        <description>&lt;p&gt;Trong những năm qua, lĩnh vực &lt;code class=&quot;highlighter-rouge&quot;&gt;Trí tuệ Nhân tạo&lt;/code&gt; nói chung và &lt;code class=&quot;highlighter-rouge&quot;&gt;Machine Learning&lt;/code&gt; nói riêng đã đạt được rất nhiều thành công nổi bật, đặc biệt là khi có sự xuất hiện của &lt;em&gt;Deep Learning&lt;/em&gt;. Tuy vậy, vẫn tồn tại một vấn đề rất lớn mà các nhà nghiên cứu trong lĩnh vực Trí tuệ Nhân tạo phải đối mặt, đó là các thuật toán Machine Learning đòi hỏi một lượng dữ liệu dán nhãn cực lớn, Deep Learning còn đòi hỏi một lượng dữ liệu lớn hơn nhiều lần. Dữ liệu dán nhãn không luôn luôn có sẵn đối với mọi tác vụ, và chi phí để có thể thu thập một lượng dữ liệu dán nhãn đủ để có thể training các thuật toán một cách tốt nhất là rất đắt đỏ.&lt;/p&gt;

&lt;p&gt;Vì thế mà đã có nhiều nghiên cứu được thực hiện và một số phương pháp được đề xuất để phần nào đó giải quyết vấn đề nan giải này. Những phương pháp này thường được gọi là “&lt;code class=&quot;highlighter-rouge&quot;&gt;Learning to Learn&lt;/code&gt;”:&lt;/p&gt;

&lt;h4 id=&quot;transfer-learning&quot;&gt;Transfer Learning&lt;/h4&gt;

&lt;p&gt;Trước tiên, hãy nói về &lt;code class=&quot;highlighter-rouge&quot;&gt;Transfer Learning&lt;/code&gt;, một khái niệm dường như phổ biến, được nhiều người biết đến hơn. Trong hội thảo &lt;code class=&quot;highlighter-rouge&quot;&gt;NIPS 2016&lt;/code&gt;, &lt;em&gt;Andrew Ng&lt;/em&gt; đã nhận định rằng Transfer Learning, sau Supervise Learning, sẽ là động lực chính để định hướng cho sự phát triển của Machine Learning trong tương lai.&lt;/p&gt;

&lt;div class=&quot;wrapper-center&quot;&gt;
    &lt;img src=&quot;https://cdn.ereka.vn/2018/04/09/c2958b20690f5b747b1fab63d9a488df.png&quot; alt=&quot;Machine learning, learning to learn, transfer learning&quot; /&gt;
&lt;/div&gt;

&lt;p&gt;Khái niệm Transfer Learning được nhắc đến lần đầu tiên tại workshop có tên là “Learning to learn”, bàn về những phương pháp Machine Learning cho phép lưu giữ và tái sử dụng những thông tin thuật toán đã học được, trong hội thảo NIPS-95. Kể từ đó, Transfer Learning thu hút ngày càng nhiều sự chú ý. Ý tưởng chung của Transfer Learning là chia sẻ các kiến thức mà hệ thống AI đã nhận được từ quá trình training của tác vụ/domain gốc (source) sang cho một tác vụ /domain mục tiêu (target).&lt;/p&gt;

&lt;h4 id=&quot;multitask-learning&quot;&gt;Multitask Learning&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Multitask Learning&lt;/code&gt; được phân chia như là một nhóm nhỏ trong Transfer Learning. Tuy vậy, không phải nhà khoa học nào cũng đồng ý với sự phân biệt này, một số coi Multitask Learning và Transfer Learning là những khái niệm tương đồng.&lt;/p&gt;

&lt;p&gt;Sự khác biệt lớn nhất ở đây là trong Transfer Learning, có sự phân biệt giữa tác vụ/domain gốc và tác vụ/domain mục tiêu. Mà trong đó, tác vụ/domain mục tiêu có vai trò quan trọng hơn. Trong Multitask Learning, các tác vụ/domain có vai trò bình đẳng hơn.&lt;/p&gt;

&lt;h4 id=&quot;meta-learning&quot;&gt;Meta Learning&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Meta Learning&lt;/code&gt; là một thuật ngữ xuất phát từ lĩnh vực Tâm lý Xã hội với định nghĩa gốc là &lt;em&gt;“the process by which learners become aware of and increasingly in control of habits of perception, inquiry, learning, and growth that they have internalized”.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Nói một cách ngắn gọn, Meta Learning được dùng để chỉ việc con người nhận thức và làm chủ được quá trình tiếp thu kiến thức của mình.&lt;/p&gt;

&lt;p&gt;=&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;Learning to Learn&lt;/code&gt; vẫn còn là một lĩnh vực rất mới trong Trí tuệ Nhân tạo. 03 phương pháp tiếp cận được nêu trên cũng chỉ là những đại diện nổi bật nhất của Learning to Learn.&lt;/p&gt;

&lt;p&gt;Thông tin ở bài viết trên đây được tham khảo từ nguồn &lt;code class=&quot;highlighter-rouge&quot;&gt;Tạp chí AI&lt;/code&gt;.&lt;/p&gt;
</description>
        <pubDate>Thu, 07 Mar 2019 00:00:00 +0000</pubDate>
        <link>/Ban-da-biet-ve-Learning-to-Learn-Linh-vuc-rat-moi-cua-Tri-tue-nhan-tao/</link>
        <guid isPermaLink="true">/Ban-da-biet-ve-Learning-to-Learn-Linh-vuc-rat-moi-cua-Tri-tue-nhan-tao/</guid>
        
        
        <category>Machine Learning</category>
        
        <category>deep learning</category>
        
        <category>neural network</category>
        
      </item>
    
      <item>
        <title>Chia sẻ về Mạng nơ-ron tích chập (Convolutional Neural Networks or ConvNEts)</title>
        <description>&lt;p&gt;Với sự phát triển phần cứng mạnh mẽ cho phép tính toán song song hàng tỉ phép tính, tạo tiền đề cho Mạng nơ-ron tích chập trở nên phổ biến và đóng vai trò quan trọng trong sự phát triển của trí tuệ nhân tạo nói chung và xử lý ảnh nói riêng.&lt;/p&gt;

&lt;h4 id=&quot;sơ-lược&quot;&gt;Sơ lược&lt;/h4&gt;

&lt;p&gt;Một trong các ứng dụng quan trọng của mạng nơ-ron tích chập đó là cho phép các máy tính có khả năng “nhìn” và “phân tích”. Nó được lấy cảm hứng từ vỏ não thị giác. Nôm na là Convnets (Convolutional Neural Networks) được sử dụng để nhận dạng hình ảnh bằng cách đưa nó qua mạng nơ-ron với nhiều layer, mỗi layer là các bộ lọc tích chập. Sau khi đi qua các layer này chúng ta có được đặc trưng và dùng nó nhận dạng ra đối tượng.&lt;/p&gt;

&lt;p&gt;Mỗi khi chúng ta nhìn thấy một cái gì đó, một loạt các lớp tế bào thần kinh được kích hoạt, và mỗi lớp thần kinh sẽ phát hiện một tập hợp các đặc trưng như đường thẳng, cạnh, màu sắc,v.v.v của đối tượng. lớp thần kinh càng cao sẽ phát hiện các đặc trưng phức tạp hơn để nhận ra những gì chúng ta đã thấy.&lt;/p&gt;

&lt;p&gt;Bài viết này sẽ trình bày một cách ngắn gọn về cấu tạo của Mạng nơ-ron tích chập, nói là ngắn gọn nhưng không hề ngắn ngọn chút nào… (?? :D ??) ý mình mình sẽ viết một cách đơn gián nhất để cho những bạn chỉ mới biết căn bản của học máy hay chưa từng biết gì về xử lý ảnh cũng có thể nắm bắt được tư tưởng của mạng tích chập. Chi tiết hơn cho mỗi phần mình sẽ viết cụ thể ở các bài sau.&lt;/p&gt;

&lt;p&gt;ConvNet có 02 phần chính: &lt;code class=&quot;highlighter-rouge&quot;&gt;Lớp trích lọc đặc trưng của ảnh (Conv, Relu và Pool)&lt;/code&gt; và &lt;code class=&quot;highlighter-rouge&quot;&gt;Lớp phân loại (FC và softmax)&lt;/code&gt;.&lt;/p&gt;

&lt;div class=&quot;wrapper-center&quot;&gt;
    &lt;img src=&quot;/assets/images/loda1551717776514/2.jpg&quot; alt=&quot;Convolutional Neural Networks&quot; /&gt;
&lt;/div&gt;

&lt;h4 id=&quot;đầu-vào-dữ-liệu-training&quot;&gt;Đầu vào (dữ liệu training):&lt;/h4&gt;

&lt;p&gt;Đầu vào của Convnets là một bức ảnh được biểu diển bởi ma trận pixel với kích thước: &lt;code class=&quot;highlighter-rouge&quot;&gt;[w x h x d]&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;W&lt;/code&gt;: chiều rộng&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;H&lt;/code&gt;: chiều cao&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;D&lt;/code&gt;: Là độ sâu, hay dễ hiểu là số lớp màu của ảnh. Ví dụ ảnh RBG sẽ là 3 lớp ảnh Red, Green, Blue&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;wrapper-center&quot;&gt;
    &lt;img src=&quot;/assets/images/loda1551717776514/3.png&quot; alt=&quot;Convolutional Neural Networks&quot; /&gt;
&lt;/div&gt;

&lt;p&gt;&lt;em&gt;Ví dụ về khái niệm channel (kênh màu) của ảnh RBG và ảnh xám&lt;/em&gt;&lt;/p&gt;

&lt;h4 id=&quot;conv-layer&quot;&gt;Conv Layer:&lt;/h4&gt;

&lt;p&gt;Trước khi nói vào lớp conv layer, chúng ta cần biết phép tích chập là cái gì đã :v. Rất dễ thôi, bạn nhìn ảnh này:&lt;/p&gt;

&lt;div class=&quot;wrapper-center&quot;&gt;
    &lt;img src=&quot;/assets/images/loda1551717776514/5.jpg&quot; alt=&quot;Convolutional Neural Networks&quot; /&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;Chúng ta có một ma trận là &lt;code class=&quot;highlighter-rouge&quot;&gt;Kernel&lt;/code&gt;, khi chiếu nó lên 1 vùng của bức ảnh. Mấy từng phần tử tương ứng của ảnh, nhân nó với phần tử tương ứng của &lt;code class=&quot;highlighter-rouge&quot;&gt;Kernel&lt;/code&gt;. Sau đó lấy tổng. Ta-daaaa.&lt;/p&gt;

&lt;p&gt;Mục tiêu của các lớp tích chập là trích chọn các đặc trưng của ảnh đầu vào.&lt;/p&gt;

&lt;div class=&quot;wrapper-center&quot;&gt;
    &lt;img src=&quot;/assets/images/loda1551717776514/4.gif&quot; alt=&quot;Convolutional Neural Networks&quot; /&gt;
&lt;/div&gt;

&lt;p&gt;&lt;em&gt;Ví dụ của Conv layer. (Nguồn : CS231n notes.)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Thực chất, ở các layer đầu tiên, phép tích chập đơn giản là phép tìm biên ảnh, nếu các bạn có kiến thức cơ bản về xử lý ảnh. Còn nếu không thì bạn có thể hiểu đơn giản như này, sau khi cho qua bộ lọc thì (với 9 điểm ảnh chẳng hạn), nó sẽ lấy ra 1 diểm nổi bật nhất, làm hiện lên các đặc trưng của đối tượng trong ảnh như đường viền xung quanh đối tượng, các góc cạnh,v.v.., và các layer tiếp theo sẽ lại trích xuất tiếp các đặc trưng của đặc trưng của các đối tượng đó, việc có nhiều layer như vậy cho phép chúng ta chia nhỏ đặc trưng của ảnh tới mức nhỏ nhất có thể. Vì thế mới gọi là mạng đặc trưng.&lt;/p&gt;

&lt;h4 id=&quot;dưới-đây-là-một-số-các-khái-niệm-cơ-bản-của-phần-này&quot;&gt;Dưới đây là một số các khái niệm cơ bản của phần này:&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Filter&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;Kernel&lt;/code&gt; hay &lt;code class=&quot;highlighter-rouge&quot;&gt;Feature Detector&lt;/code&gt; đều là cách gọi của ma trận tích chập &lt;code class=&quot;highlighter-rouge&quot;&gt;filter matrix&lt;/code&gt; (như mình đã đề cập ở trên), ma trận này là 1 ma trận hệ số, và quét toàn bộ bức ảnh, mỗi lần quét thì tính tích chập trên vùng bị quét. Thông thường, ở các lớp đầu tiên của ma trận này sẽ có kích thước là &lt;code class=&quot;highlighter-rouge&quot;&gt;[5x5x3]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Convolved Feature&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;Activation Map&lt;/code&gt; hay &lt;code class=&quot;highlighter-rouge&quot;&gt;Feature Map&lt;/code&gt; là đầu ra của ảnh khi cho bộ lọc chạy hết bức ảnh với phép tích chập.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Receptive field&lt;/code&gt; là vùng ảnh được chọn để tính tích chập, hay bằng đúng cái kích thước của bộ lọc.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Depth&lt;/code&gt; là số lượng bộ lọc. Lưu ý:  ở đây là số lượng bộ lọc (filter) chứ không phải số lượng kênh màu RBG như ở trên.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Stride&lt;/code&gt; được hiểu là khoảng cách dịch chuyển của bộ lọc sau mỗi lần tính. Ví dụ khi &lt;code class=&quot;highlighter-rouge&quot;&gt;stride=2&lt;/code&gt;. Tức sau khi tính xong tại 1 vùng ảnh, nó sẽ dịch sang phải 2 pixel. Tương tự với việc dịch xuống dưới&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Zero-Padding&lt;/code&gt; là việc thêm các giá trị 0 ở xung quanh biên ảnh, để đảm bảo phép tích chập được thực hiện đủ trên toàn ảnh.&lt;/p&gt;

&lt;h4 id=&quot;vậy-kích-thước-đầu-ra-của-ảnh-với-mỗi-layer-được-tính-như-thế-nào&quot;&gt;Vậy kích thước đầu ra của ảnh với mỗi layer được tính như thế nào?&lt;/h4&gt;

&lt;p&gt;Giả sử ảnh đầu ra là &lt;code class=&quot;highlighter-rouge&quot;&gt;[W2 x H2 x D2]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Thì:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;W2 = (W1 – F + 2P) / S + 1&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;H2 = (H1 – F +2P) / S + 1&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;D2 = K&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Trong đó:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;[W1xH1xD1]&lt;/code&gt;: Kích thước ảnh đầu vào&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;F&lt;/code&gt;: Kích thước của bộ lọc &lt;code class=&quot;highlighter-rouge&quot;&gt;Kernel&lt;/code&gt; (NxN)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;S&lt;/code&gt;: giá trị &lt;code class=&quot;highlighter-rouge&quot;&gt;Stride&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;P&lt;/code&gt;: số lượng zero-padding thêm vào viền ảnh&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;K&lt;/code&gt;: Số lượng bộ lọc (&lt;code class=&quot;highlighter-rouge&quot;&gt;Depth&lt;/code&gt;)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Ví dụ:&lt;/p&gt;

&lt;p&gt;Kích thước đầu ra của lớp đầu tiên trong kiến trúc Deep Convolutional Neural Networks đã từng chiến thắng ImageNet Chanllenge 2012 là:&lt;/p&gt;

&lt;p&gt;Đầu vào: &lt;code class=&quot;highlighter-rouge&quot;&gt;[227x227x3]&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;W=227&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;F=11&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;S=4&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;P=0&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;K=96&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Đầu ra:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;227&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;11&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;55&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Vậy kích thước đầu ra của layer đầu tiên là &lt;code class=&quot;highlighter-rouge&quot;&gt;[55x55x96].&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&quot;relu-layer&quot;&gt;ReLU Layer:&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ReLU Layer&lt;/code&gt; áp dụng các hàm kích hoạt (&lt;code class=&quot;highlighter-rouge&quot;&gt;activation function&lt;/code&gt;) &lt;code class=&quot;highlighter-rouge&quot;&gt;max(0,x)&lt;/code&gt; lên đầu ra của &lt;code class=&quot;highlighter-rouge&quot;&gt;Conv Layer&lt;/code&gt;, có tác dụng đưa các giá trị âm về thành 0. Layer này không thay đổi kích thước của ảnh và không có thêm bất kì tham số nào.&lt;/p&gt;

&lt;p&gt;Mục đích của lớp ReLu là đưa ảnh một mức ngưỡng, ở đây là 0. Để loại bỏ các giá trị âm không cần thiết mà có thể sẽ ảnh hưởng cho việc tính toán ở các layer sau đó.&lt;/p&gt;

&lt;h4 id=&quot;pool-layer&quot;&gt;Pool Layer:&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Pool Layer&lt;/code&gt; thực hiện chức năng làm giảm chiều không gian của đầu vào và giảm độ phức tạp tính toán của model. Ngoài ra, &lt;code class=&quot;highlighter-rouge&quot;&gt;Pool Layer&lt;/code&gt; còn giúp kiểm soát hiện tượng &lt;code class=&quot;highlighter-rouge&quot;&gt;overffiting&lt;/code&gt;. Thông thường, &lt;code class=&quot;highlighter-rouge&quot;&gt;Pool layer&lt;/code&gt; có nhiều hình thức khác nhau phù hợp cho nhiều bài toán, tuy nhiên &lt;code class=&quot;highlighter-rouge&quot;&gt;Max Pooling&lt;/code&gt; là được sử dụng nhiều và phổ biến hơn cả, với ý tưởng cũng rất sát với thực tế: &lt;em&gt;“Giữ lại chi tiết quan trọng”&lt;/em&gt; hay hiểu ở trong bài toán này chính giữ lại pixel có giá trị lớn nhất.&lt;/p&gt;

&lt;p&gt;Ví dụ: &lt;code class=&quot;highlighter-rouge&quot;&gt;Max pooling&lt;/code&gt; với bộ lọc &lt;code class=&quot;highlighter-rouge&quot;&gt;2x2&lt;/code&gt; và &lt;code class=&quot;highlighter-rouge&quot;&gt;stride = 2&lt;/code&gt;. Bộ lọc sẽ chạy dọc ảnh. Và với mỗi vùng ảnh được chọn, sẽ chọn ra 1 giá trị lớn nhất và giữ lại.&lt;/p&gt;

&lt;div class=&quot;wrapper-center&quot;&gt;
    &lt;img src=&quot;/assets/images/loda1551717776514/6.png&quot; alt=&quot;Convolutional Neural Networks&quot; /&gt;
&lt;/div&gt;

&lt;p&gt;Max pooling kernel 2x2, stride = 2. Nguồn: Wikipedia&lt;/p&gt;

&lt;p&gt;Thông thường max pooling có kích thước là &lt;code class=&quot;highlighter-rouge&quot;&gt;2x2&lt;/code&gt; và &lt;code class=&quot;highlighter-rouge&quot;&gt;stride=2&lt;/code&gt;. Nếu lấy giá trị quá lớn, thay vì giúp đỡ thì nó lại làm phá vỡ cấu trúc ảnh và mất mát thông tin nghiêm trọng (==!). Vì vậy mà một số chuyên gia không thích sử dụng layer này mà thay vào đó sử dụng thêm các lớp Conv Layer và tăng số stride lên mỗi lần.&lt;/p&gt;

&lt;h4 id=&quot;fully_connected-layer-fc&quot;&gt;Fully_Connected Layer (FC):&lt;/h4&gt;

&lt;p&gt;Tên tiếng việt là &lt;code class=&quot;highlighter-rouge&quot;&gt;Mạng liên kết đầy đủ&lt;/code&gt;. Tại lớp mạng này, mỗi một nơ-ron của layer này sẽ liên kết tới mọi nơ-ron của lớp khác. Để đưa ảnh từ các layer trước vào mạng này, buộc phải dàn phẳng bức ảnh ra thành 1 vector thay vì là mảng nhiều chiều như trước. Tại layer cuối cùng sẽ sử dụng 1 hàm kinh điển trong học máy mà bất kì ai cũng từng sử dụng đó là &lt;code class=&quot;highlighter-rouge&quot;&gt;softmax&lt;/code&gt; để phân loại đối tượng dựa vào vector đặc trưng đã được tính toán của các lớp trước đó.&lt;/p&gt;

&lt;p&gt;Trên đây là tóm tắt kiến trúc cơ bản của một mạng tích chập, trên thực tế sẽ có nhiều kiến trúc phức tạp hơn rất nhiều với độ chính xác gần bằng con người. Mình sẽ viết các bài tiếp theo kĩ hơn vào từng phần và giới thiệu cho các bạn các kiến trúc mới.&lt;/p&gt;

</description>
        <pubDate>Mon, 04 Mar 2019 00:00:00 +0000</pubDate>
        <link>/Chia-se-ve-Mang-no-ron-tich-chap-(Convolutional-Neural-Networks-or-ConvNEts)/</link>
        <guid isPermaLink="true">/Chia-se-ve-Mang-no-ron-tich-chap-(Convolutional-Neural-Networks-or-ConvNEts)/</guid>
        
        
        <category>Machine Learning</category>
        
        <category>image processing</category>
        
        <category>deep learning</category>
        
        <category>neural network</category>
        
        <category>CNN</category>
        
        <category>Convolutional</category>
        
      </item>
    
      <item>
        <title>Trợ lý ảo vẫn sẽ là xu hướng công nghệ 2019</title>
        <description>&lt;p&gt;Những năm gần đây, Trợ lý ảo đã dần trở thành xu hướng công nghệ được đón đầu. Các “ông lớn” làng công nghệ thế giới đã cho ra đời các trợ lý ảo, được nhiều người biết đến như: Apple Siri, Google Assistant, Amazon Alexa, Microsoft Cortana.&lt;/p&gt;

&lt;p&gt;Và đương nhiên vẫn còn nhiều trợ lý ảo khác được phát triển bởi các công ty công nghệ trên thế giới, có cả Việt Nam. Trong đó có cả Viettel, nơi mình và team đang phát triển 1 trợ lý ảo.&lt;/p&gt;

&lt;h2 id=&quot;trợ-lý-ảo-là-gì-mà-lại-trở-thành-xu-hướng-công-nghệ-2019&quot;&gt;Trợ lý ảo là gì mà lại trở thành xu hướng công nghệ 2019?&lt;/h2&gt;

&lt;p&gt;Có thể hiểu đơn giản trợ lý ảo là phần mềm, công cụ được xây dựng dựa trên nền tảng trí thông minh nhân tạo (AI) và thường được các nhà phát triển công nghệ tích hợp sâu vào trong hệ điều hành với mục đích chính là hỗ trợ người dùng thiết bị dễ dàng hơn bằng chính thói quen mà người dùng thường làm trên thiết bị (như các trợ lý ảo mình liệt kê ở trên).&lt;/p&gt;

&lt;h2 id=&quot;ưu-điểm-của-trợ-lý-ảo-là-gì&quot;&gt;Ưu điểm của trợ lý ảo là gì?&lt;/h2&gt;

&lt;h3 id=&quot;khả-năng-nhận-diện-giọng-nói-và-phân-tích-văn-bản-voice-to-text--text-to-voice&quot;&gt;Khả năng nhận diện giọng nói và phân tích văn bản (Voice to Text – Text to Voice)&lt;/h3&gt;

&lt;p&gt;Bằng trí thông minh nhân tạo, những trợ lý ảo có thể nhận diện giọng nói chính xác, cho phép người dùng có thể tương tác với máy tính bằng giọng nói dễ dàng. Ví dụ, trợ lý ảo Siri của Apple sẽ bắt đầu khởi chạy ngay khi bạn nói “Hey Siri” thay vì phải nhấn giữ nút Home trên iPhone, iPad, sau đó có thể tiếp tục ra lệnh cho Siri thực hiện những điều bạn muốn.&lt;/p&gt;

&lt;h3 id=&quot;khả-năng-xử-lý-ngôn-ngữ-tự-nhiên-công-nghệ-nlp--natual-language-process&quot;&gt;Khả năng xử lý ngôn ngữ tự nhiên (Công nghệ NLP – Natual Language Process)&lt;/h3&gt;

&lt;p&gt;Trợ lý ảo còn có thể xử lý ngôn ngữ và đưa ra những câu trả lời phản hồi người dùng, tạo nên sự tương tác giữa người dùng và thiết bị giống hệt cuộc nói chuyện giữa người với người.&lt;/p&gt;

&lt;h4 id=&quot;sức-mạnh-tìm-kiếm-search-engine&quot;&gt;Sức mạnh tìm kiếm (Search Engine)&lt;/h4&gt;

&lt;p&gt;“Đứng sau” trợ giúp cho tính năng tìm kiếm của các trợ lý ảo chính là những công cụ đình đám như Bing, Google Search, thư viện bách khoa toàn thư Wikipedia hay Wolfram Alpha. Với những kho dữ liệu khổng lồ như vậy, rõ ràng những trợ lý ảo sẽ có khả năng tìm kiếm cực kỳ mạnh mẽ cả về tốc độ lẫn sự chính xác trong kết quả tìm kiếm.&lt;/p&gt;

&lt;h4 id=&quot;khả-năng-học-từ-người-dùng&quot;&gt;Khả năng học từ người dùng&lt;/h4&gt;

&lt;p&gt;Trợ lý ảo hoàn toàn có thể thu thập dữ liệu từ các thói quen sử dụng, tìm kiếm dữ liệu của người dùng và đưa ra những gợi ý chính xác nhất, và Trợ lý ảo sẽ “học” từ thói quen người dùng và trở nên “giỏi” hơn mỗi ngày.&lt;/p&gt;

&lt;h4 id=&quot;trợ-lý-ảo-được-thực-tế-hóa-ở-các-phiên-bản&quot;&gt;Trợ lý ảo được thực tế hóa ở các phiên bản:&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;Robot&lt;/li&gt;
  &lt;li&gt;Website&lt;/li&gt;
  &lt;li&gt;Mobile Application&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;mô-hình-khái-quát-về-việc-lập-trình-trợ-lý-ảo-mà-team-mình-đang-phát-triển&quot;&gt;Mô hình khái quát về việc lập trình Trợ lý ảo mà team mình đang phát triển:&lt;/h3&gt;

&lt;p&gt;Hệ thống sẽ nhận đầu vào là giọng nói hoặc văn bản. Lúc này hệ thống sẽ tiền xử lý dữ liệu, nếu là giọng nói sẽ chuyển thành văn bản để xử lý bằng công nghệ speech2text (Model này là của công ty mình tự huấn luyện). Sau đó văn bản sẽ được xử lý và trích xuất thông tin thông qua tầng xử lý ngôn ngữ.&lt;/p&gt;

&lt;p&gt;Lúc này các thông tin được trích xuất bao gồm Intent (dự định, ý định) của người dùng, Object (Đối tượng) trong câu nói đó, ngoài ra còn nhiều thông tin bổ sung khác như Location, Name, v.v.. Các thông tin này sẽ được bọn mình xử lý trên các model hoặc AIML training sẵn. Từ đó trả dữ liệu về cho người dùng.&lt;/p&gt;

&lt;p&gt;Đặc biệt, điểm mạnh của trợ lý ảo hiện nay vẫn nằm ở hệ thống Search Engine, đa phần người dùng sẽ có thiên hướng tìm kiếm và hỏi đáp. Vậy nên khi xác định Intent của người dùng là tìm kiếm, bọn mình sẽ sử dụng hệ thống SE do công ty tự phát triển để tìm kiếm các thông tin chính xác nhất và gửi kêt quả về cho người dùng.&lt;/p&gt;

&lt;p&gt;Hằng ngày team mình sẽ tối ưu Trợ lý ảo bằng các công nghệ:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Công nghệ nhận dạng và xử lý tiếng nói (Voice to text - Text to voice)&lt;/li&gt;
  &lt;li&gt;Xử lý ngôn ngữ tự nhiên (Natural Language Processing)&lt;/li&gt;
  &lt;li&gt;Trí tuệ nhận tạo (AI)&lt;/li&gt;
  &lt;li&gt;AIML&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Đây là sản phẩm Trợ lý ảo do team mình đang xây dựng:&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;youtube-container&quot;&gt;
    &lt;iframe src=&quot;https://www.youtube.com/embed/r8i3kQDufjk&quot; frameborder=&quot;0&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
&lt;p&gt;Công việc của một lập trình viên làm Trợ lý ảo với mình rất thú vị. Tuy nhiên mình cũng nhận được nhiều câu hỏi rằng Trợ lý ảo rất phát triển và là xu hướng Công nghệ mới nhưng là ở nước rất phát triển, không phải ở Việt Nam. Vậy theo mọi người, &lt;strong&gt;Cơ hội và thách thức cho các nhà phát triển, kỹ sư lập trình Trợ lý ảo tại Việt Nam là gì? Đây có thực sự là cơ hội mới cho các lập trình viên?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Một vài số liệu thú vị về trợ lý ảo:&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Số lượng thiết bị thông minh được tích hợp tính năng trợ lý ảo sẽ vượt mốc 7,5 tỷ vào năm 2021, cao hơn dân số toàn cầu hiện nay.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Dự kiến tới năm 2021, 47,6% thiết bị sử dụng trợ lý ảo thông qua giọng nói sẽ xuất hiện tại châu Á và châu Đại Dương. Các nền tảng trợ lý ảo đến từ Trung Quốc như Baidu, iFlytek…sẽ được sử dụng trên khoảng 43 triệu thiết bị, đi theo xu hướng tiếp tục tăng trưởng mạnh mẽ&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;(Theo nghiên cứu và nhận định từ Ovum).&lt;/em&gt;&lt;/p&gt;
</description>
        <pubDate>Sun, 03 Mar 2019 00:00:00 +0000</pubDate>
        <link>/Tro-ly-ao-van-se-la-xu-huong-cong-nghe-2019/</link>
        <guid isPermaLink="true">/Tro-ly-ao-van-se-la-xu-huong-cong-nghe-2019/</guid>
        
        
        <category>Virtual Assistant</category>
        
        <category>Machine Learning</category>
        
        <category>AI</category>
        
      </item>
    
  </channel>
</rss>
